<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lernplattform Begriffsdefinitionen - Ril 408.2101A01</title>
    
    <link rel="manifest" href="data:application/manifest+json,%7B%22name%22%3A%22Lernplattform%20Ril%20408%22%2C%22short_name%22%3A%22Ril%20408%20Lernen%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23F2F2F2%22%2C%22theme_color%22%3A%22%23273A73%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22https%3A%2F%2Fwww.eurobahn.de%2Ffileadmin%2Fbilder%2Flogos%2Flogo-eurobahn.svg%22%2C%22sizes%22%3A%22any%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Ril 408 Lernen">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            background-color: #F2F2F2; /* Eurobahn Off-White */
            color: #2B3959; /* Eurobahn Medium Blue */
        }
        /* Eurobahn CI Farben */
        :root {
            --eb-dark-blue: #273A73;
            --eb-medium-blue: #2B3959;
            --eb-teal: #3FA6A6;
            --eb-light-teal: #C4F2EE;
            --eb-off-white: #F2F2F2;
        }

        /* Ladebildschirm */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--eb-off-white);
            z-index: 9999;
            transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
        }
        .loader img {
            animation: pulse 1.5s infinite ease-in-out;
        }
        .loader.hidden {
            opacity: 0;
            visibility: hidden;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        /* Karten-Design */
        .card-container {
            perspective: 1000px;
        }
        .card {
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }
        .card.is-flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            border: 1px solid #e5e7eb;
        }
        .card-face-front {
            background-color: white;
            justify-content: center;
            align-items: center;
        }
        .card-face-back {
            background-color: white;
            transform: rotateY(180deg);
            justify-content: flex-start;
        }
        .card-header {
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            font-weight: 700;
            color: white;
            border-radius: 0.75rem 0.75rem 0 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        .card-content {
            padding: 1.5rem;
            overflow-y: auto;
            flex-grow: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        .correct-answer {
            background-color: #C4F2EE !important;
            color: var(--eb-dark-blue) !important;
            border: 2px solid var(--eb-teal) !important;
        }
        .wrong-answer {
            background-color: #fee2e2 !important;
            color: #991b1b !important;
            border: 2px solid #fca5a5 !important;
        }
        #feedback ins {
            background-color: #C4F2EE;
            text-decoration: none;
            padding: 0 2px;
            border-radius: 3px;
        }
        #feedback del {
            background-color: #fecaca;
            text-decoration: line-through;
            padding: 0 2px;
            border-radius: 3px;
        }
        
        /* Text overflow handling for card content */
        .card-content h2 {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        
        /* Ensure all text elements in cards handle overflow properly */
        .card-content p,
        .card-content div,
        .card-content span {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        /* Search functionality styles */
        .search-highlight {
            background-color: #fef08a;
            padding: 1px 2px;
            border-radius: 2px;
        }
        
        /* Definition quiz text overflow handling */
        .definition-quiz h2 {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        
        .definition-quiz textarea {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .definition-quiz #feedback {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        
        .definition-quiz p {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        
        .definition-quiz .answer-option {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        
        /* Begriff selection list text overflow handling */
        .term-selection-item {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }
        
        .term-selection-item span {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            word-break: break-word;
        }

        .folder-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.25rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: #f9fafb;
            transition: background-color 0.2s ease;
        }

        .folder-item:hover {
            background-color: #f3f4f6;
        }

        .folder-item button {
            margin-left: 0.5rem;
        }
    </style>
</head>
<body class="antialiased">
    <div id="loader" class="loader">
        <img src="https://upload.wikimedia.org/wikipedia/commons/2/23/BSicon_BAHN.svg" alt="Eisenbahn" class="h-20">
    </div>

    <div class="container mx-auto p-4 md:p-8 min-h-screen flex flex-col">
        <header class="text-center mb-8 border-b-2 border-gray-200 pb-4 flex flex-col sm:flex-row justify-center items-center gap-4">
            <img src="https://upload.wikimedia.org/wikipedia/commons/2/23/BSicon_BAHN.svg" alt="Eisenbahn" class="h-12 md:h-16">
            <div class="text-center sm:text-left">
                <h1 class="text-3xl md:text-4xl font-bold text-[--eb-dark-blue] tracking-wide">Lernplattform</h1>
                <p class="text-lg text-gray-500">Begriffsdefinitionen Ril 408.2101A01</p>
            </div>
        </header>

        <div id="progress-dashboard" class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 mb-6 w-full max-w-5xl mx-auto">
            <h2 class="text-xl font-semibold mb-4 text-[--eb-dark-blue]">Lernfortschritt</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                <div class="bg-gray-50 p-4 rounded-lg text-center">
                    <div class="text-2xl font-bold text-gray-700" id="total-terms">69</div>
                    <div class="text-sm text-gray-500">Begriffe gesamt</div>
                </div>
                <div class="bg-green-50 p-4 rounded-lg text-center">
                    <div class="text-2xl font-bold text-green-600" id="known-count">0</div>
                    <div class="text-sm text-green-600">Gewusst</div>
                </div>
                <div class="bg-red-50 p-4 rounded-lg text-center">
                    <div class="text-2xl font-bold text-red-600" id="unknown-count">0</div>
                    <div class="text-sm text-red-600">Nicht gewusst</div>
                </div>
                <div class="bg-blue-50 p-4 rounded-lg text-center">
                    <div class="text-2xl font-bold text-blue-600" id="neutral-count">69</div>
                    <div class="text-sm text-blue-600">Noch nicht bewertet</div>
                </div>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-4">
                <button id="filter-all" class="px-4 py-2 bg-[--eb-dark-blue] text-white rounded-lg hover:bg-[--eb-medium-blue] transition">Alle anzeigen</button>
                <button id="filter-unknown" class="px-4 py-2 bg-red-100 text-red-700 hover:bg-red-200 rounded-lg transition">Nur nicht gewusste</button>
                <button id="filter-known" class="px-4 py-2 bg-green-100 text-green-700 hover:bg-green-200 rounded-lg transition">Nur gewusste</button>
                <button id="filter-neutral" class="px-4 py-2 bg-gray-100 text-gray-700 hover:bg-gray-200 rounded-lg transition">Nur unbewertete</button>
                <button id="reset-progress" class="px-4 py-2 bg-orange-100 text-orange-700 hover:bg-orange-200 rounded-lg transition ml-auto">Fortschritt zurücksetzen</button>
            </div>
            
            <div class="w-full bg-gray-200 rounded-full h-4 mb-2">
                <div id="progress-bar" class="bg-[--eb-teal] h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p class="text-sm text-gray-600 text-center" id="progress-text">0% bewertet</p>
        </div>

        <div id="settings-view" class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 mb-8 w-full max-w-5xl mx-auto">
            <div id="settings-content">
                <h2 class="text-2xl font-semibold mb-4 text-[--eb-dark-blue]">1. Einstellungen</h2>
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3 text-gray-600">Modus auswählen:</h3>
                    <div class="flex flex-col sm:flex-row gap-4">
                        <label class="flex-1 bg-gray-100 p-4 rounded-lg cursor-pointer hover:bg-gray-200 transition duration-200 border has-[:checked]:border-[--eb-teal] has-[:checked]:bg-[--eb-light-teal]">
                            <input type="radio" name="mode" value="learn" class="mr-3 accent-[--eb-teal]" checked>
                            <span class="font-semibold">Lernmodus (Karteikarten)</span>
                        </label>
                        <label class="flex-1 bg-gray-100 p-4 rounded-lg cursor-pointer hover:bg-gray-200 transition duration-200 border has-[:checked]:border-[--eb-teal] has-[:checked]:bg-[--eb-light-teal]">
                            <input type="radio" name="mode" value="test-term" class="mr-3 accent-[--eb-teal]">
                            <span class="font-semibold">Test: Begriff &rarr; Definition</span>
                        </label>
                        <label class="flex-1 bg-gray-100 p-4 rounded-lg cursor-pointer hover:bg-gray-200 transition duration-200 border has-[:checked]:border-[--eb-teal] has-[:checked]:bg-[--eb-light-teal]">
                            <input type="radio" name="mode" value="test-def" class="mr-3 accent-[--eb-teal]">
                            <span class="font-semibold">Test: Definition &rarr; Begriff</span>
                        </label>
                    </div>
                </div>

                <div>
                    <h2 class="text-2xl font-semibold mb-4 text-[--eb-dark-blue]">2. Begriffe auswählen</h2>
                    
                    <div class="mb-6 bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <h3 class="text-lg font-medium mb-3 text-gray-600">Ordner verwalten</h3>
                        <div class="flex flex-wrap gap-2 mb-4">
                            <input type="text" id="new-folder-input" placeholder="Neuer Ordner-Name" class="flex-grow p-2 border border-gray-300 rounded-lg">
                            <button id="add-folder-btn" class="bg-[--eb-teal] hover:bg-[#358f8f] text-white font-bold py-2 px-4 rounded-lg transition duration-200">Ordner hinzufügen</button>
                        </div>
                        <div id="folder-list"></div>
                        <p id="folder-selection-count" class="text-sm text-gray-600 mt-2 font-medium"></p>
                    </div>

                    <div class="mb-4">
                        <div class="relative">
                            <input type="text" id="search-input" placeholder="Begriffe durchsuchen..." 
                                   class="w-full p-3 pr-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[--eb-teal] focus:border-[--eb-teal] text-gray-700">
                            <div class="absolute inset-y-0 right-0 pr-3 flex items-center">
                                <svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                </svg>
                            </div>
                        </div>
                        <p id="search-results-count" class="text-sm text-gray-500 mt-2 hidden"></p>
                        <p id="selection-count" class="text-sm text-gray-600 mt-1 font-medium"></p>
                    </div>
                    
                    <div class="flex flex-wrap gap-4 mb-4">
                        <button id="select-all" class="bg-[--eb-medium-blue] hover:bg-[--eb-dark-blue] text-white font-bold py-2 px-4 rounded-lg transition duration-200">Alle auswählen</button>
                        <button id="deselect-all" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition duration-200">Alle abwählen</button>
                        <button id="select-visible" class="bg-[--eb-teal] hover:bg-[#358f8f] text-white font-bold py-2 px-4 rounded-lg transition duration-200 hidden">Sichtbare auswählen</button>
                        <button id="clear-search" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 hidden">Suche löschen</button>
                    </div>
                    <div id="term-selection" class="max-h-64 overflow-y-auto grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 bg-gray-50 p-4 rounded-lg border border-gray-200">
                    </div>
                </div>

                <div class="mt-8 text-center">
                    <button id="start-btn" class="bg-[--eb-teal] hover:bg-[#358f8f] text-white font-bold text-xl py-3 px-10 rounded-lg transition duration-200 shadow-md">Sitzung starten</button>
                </div>
            </div>
            <div id="no-selection-warning" class="hidden text-center text-red-700 font-semibold bg-red-100 p-4 rounded-lg border border-red-300 mt-4">
                Bitte wählen Sie mindestens einen Begriff aus, um zu starten.
            </div>
        </div>

        <main id="main-view" class="hidden flex-grow flex flex-col items-center justify-center w-full"></main>

    </div>

    <script>
        const definitions = [
            { term: "Ablaufen, Abdrücken", definition: "Ablaufen ist das Bewegen von Fahrzeugen durch Schwerkraft im Allgemeinen von einem Ablaufberg herab, über den die Fahrzeuge abgedrückt werden." },
            { term: "Abstellen", definition: "Züge und Triebfahrzeuge sind abgestellt, wenn sie nicht mit einem Triebfahrzeugführer besetzt sind oder nicht gesteuert werden. Wagen sind abgestellt, sofern sie nicht in Züge eingestellt sind oder nicht rangiert werden." },
            { term: "Abstoßen", definition: "Abstoßen ist das Bewegen geschobener, nicht mit einem arbeitenden Triebfahrzeug gekuppelter Fahrzeuge durch Beschleunigen, so dass die Fahrzeuge allein weiterfahren, nachdem das Triebfahrzeug angehalten hat." },
            { term: "Abzweigstellen", definition: "Abzweigstellen sind Blockstellen der freien Strecke, wo Züge von einer Strecke auf eine andere Strecke übergehen können. Eine Abzweigstelle wird durch ihre Blocksignale bzw. Signale Ne 14 begrenzt." },
            { term: "Anschlussbahnhöfe", definition: "Anschlussbahnhöfe haben besondere Aufgaben bei der Meldung der Züge." },
            { term: "Anschlussstellen, Ausweichanschlussstellen", definition: "Anschlussstellen sind Bahnanlagen der freien Strecke, wo Züge ein angeschlossenes Gleis als Rangierfahrt befahren können. Es sind zu unterscheiden:\na) Anschlussstellen, bei denen die Blockstrecke nicht für einen anderen Zug freigegeben wird,\nb) Anschlussstellen, bei denen die Blockstrecke für einen anderen Zug freigegeben wird (Ausweichanschlussstellen)." },
            { term: "Anzeigegeführt", definition: "Ein Zug ist anzeigegeführt, wenn eine Zugbeeinflussung (LZB, ETCS) wirkt, die den Zug selbsttätig zum Halten bringen kann und außerdem führt, d. h. Führungsgrößen im Führerraum anzeigt, die für den Fahrtverlauf zulässigen Geschwindigkeiten kontinuierlich überwacht und ggf. die Geschwindigkeit selbsttätig regelt. Anzeigegeführte Züge können LZB-geführt oder ETCS-geführt sein." },
            { term: "Arbeitendes Triebfahrzeug", definition: "Ein Triebfahrzeug ist arbeitend, wenn es Antriebskraft erzeugt." },
            { term: "aS-Zug", definition: "aS-Züge sind Züge mit häufig vorkommenden außergewöhnlichen Sendungen, die im Fahrplan für Zugmeldestellen und Streckenfahrplan durch den Zusatz „aS“ hinter der Zugnummer gekennzeichnet sind." },
            { term: "Aufdrücken", definition: "Aufdrücken ist das Bewegen von Fahrzeugen zum Entkuppeln oder von kuppelreif stehenden Fahrzeugen zum Kuppeln." },
            { term: "Aufgehobene Signalabhängigkeit", definition: "Signalabhängigkeit ist in folgenden Fällen aufgehoben:\nEin Hauptsignal kann auf Fahrt gestellt werden und eine Fachkraft hat im Arbeits- und Störungsbuch die Abhängigkeit für aufgehoben erklärt.\nEin Hauptsignal kann auf Fahrt gestellt werden und die Zungen- oder Herzstückverschlüsse von Weichen wirken nicht ordnungsgemäß.\nBei einer virtuellen Blockstelle entspricht deren Fahrtmelder der Fahrtstellung des Hauptsignals." },
            { term: "Bahnanlagen", definition: "Es gibt Bahnanlagen der Bahnhöfe, der freien Strecke und sonstige Bahnanlagen." },
            { term: "Bahnbetrieb", definition: "Bahnbetrieb ist das Bewegen von Fahrzeugen. Zum Bahnbetrieb gehören das Fahren von Zügen und das Rangieren." },
            { term: "Bahnhöfe, Bahnhofsteile", definition: "Bahnhöfe sind Bahnanlagen mit mindestens einer Weiche, wo Züge beginnen, enden, halten, kreuzen, überholen oder wenden dürfen. Bahnhöfe können in Bahnhofsteile unterteilt sein. Bahnhofsteile können durch Zwischensignale bzw. Signale Ne 14 gegeneinander abgegrenzt sein." },
            { term: "Balise, Balisengruppe", definition: "Eine Balise ist ein im Gleis angeordnetes Datenübertragungselement. Bei ETCS übertragen Balisen Informationen zur Fahrzeugortung. Um die Fahrtrichtung eindeutig herleiten zu können, können Balisen zu einer Balisengruppe zusammengefasst sein. Bei ETCS-Level 1 übertragen schaltbare Balisen zusätzlich zur Ortung auch ETCS-Fahrterlaubnisse. An Signalen Ne 14 sind Balisen mit der Information „Halt in ETCS-Betriebsart SR“ verlegt. Bei Neigetechnik übertragen Balisen Informationen für die Geschwindigkeitsüberwachung für Neigetechnik." },
            { term: "Bedarfshalt", definition: "Ein Bedarfshalt ist ein Fahrplanhalt, bei dem ein Zug auf der Betriebsstelle halten muss, wenn:\n- der Triebfahrzeugführer ein Haltsignal oder ein blinkendes Signal Ne 5 erhält,\n- der Triebfahrzeugführer Reisende bemerkt, die ein- oder aussteigen wollen,\n- die Fahrgasthaltewunscheinrichtung dem Triebfahrzeugführer einen Haltewunsch anzeigt oder\n- der Triebfahrzeugführer nicht verständigt wurde, dass der Halt ausfallen darf." },
            { term: "Beidrücken", definition: "Beidrücken ist das Bewegen getrennt stehender Fahrzeuge zum Kuppeln." },
            { term: "Betriebliche Abfahrtszeit", definition: "Die betriebliche Abfahrtzeit ist für die Abfahrt des Zuges auf einer Betriebsstelle maßgeblich. In den Fahrplänen dieser Betriebsstellen können daneben auch verkehrliche Abfahrtzeiten veröffentlich sein." },
            { term: "Betriebshalt", definition: "Ein Betriebshalt ist ein Fahrplanhalt, bei dem ein Zug auf der Betriebsstelle halten muss, wenn der Triebfahrzeugführer ein Haltsignal erhält." },
            { term: "Betriebsstellen", definition: "Betriebsstellen sind:\na) Bahnhöfe, Blockstellen, Abzweigstellen, Anschlussstellen, Haltepunkte, Haltestellen, Deckungsstellen oder\nb) Stellen in den Bahnhöfen oder auf der freien Strecke, die der unmittelbaren Regelung und Sicherung der Zugfahrten und des Rangierens dienen." },
            { term: "Blockstellen", definition: "Blockstellen sind Bahnanlagen, die eine Blockstrecke begrenzen. Eine Blockstelle kann zugleich als Bahnhof, Abzweigstelle, Überleitstelle, Anschlussstelle, Haltepunkt, Haltestelle oder Deckungsstelle eingerichtet sein. Es gibt Blockstellen für signalgeführte Züge, für anzeigegeführte Züge und für Züge in ETCS-Betriebsart SR. Blockstellen für signalgeführte Züge sind an Hauptsignalen eingerichtet. Blockstellen für anzeigegeführte Züge sind eingerichtet an Hauptsignalen oder als virtuelle Blockstellen. Blockstellen für Züge in ETCS-Betriebsart SR sind an Signalen Ne 14 eingerichtet." },
            { term: "Blockstrecken", definition: "Blockstrecken sind Gleisabschnitte, in die ein Zug nur einfahren darf, wenn sie frei von Fahrzeugen sind. Es gibt Blockstrecken für signalgeführte und für anzeigegeführte Züge." },
            { term: "Deckungsstellen", definition: "Deckungsstellen sind Bahnanlagen der freien Strecke, die den Bahnbetrieb insbesondere an beweglichen Brücken, Kreuzungen von Bahnen, Gleisverschlingungen oder Baustellen sichern." },
            { term: "Durchgehende Hauptgleise", definition: "Durchgehende Hauptgleise sind die Hauptgleise der freien Strecke und ihre Fortsetzung in den Bahnhöfen." },
            { term: "Einfahrweiche", definition: "Die Einfahrweiche ist die erste Weiche eines Bahnhofs, die bei Einfahrt von der freien Strecke her befahren wird." },
            { term: "ETCS-Fahrterlaubnis", definition: "Die ETCS-Fahrterlaubnis ist die Erlaubnis für einen ETCS-geführten Zug, bis zu einer bestimmten Stelle, dem ETCS-Halt, zu fahren." },
            { term: "ETCS-Halt", definition: "Ein ETCS-Halt ist die Stelle, an der die ETCS-Fahrterlaubnis eines ETCS-geführten Zuges endet. Dem Triebfahrzeugführer wird ein ETCS-Halt durch eine Zielgeschwindigkeit von 0 km/h angekündigt und durch eine Sollgeschwindigkeit von 0 km/h angezeigt. In ETCS-Betriebsart SR wird dem Triebfahrzeugführer ein ETCS-Halt durch ein Signal Ne 14 angezeigt." },
            { term: "ETCS-Zentrale", definition: "Zu einer ETCS-Zentrale gehören:\n- die ETCS-Bedieneinrichtung,\n- ein sicheres Rechnersystem und\n- die Schnittstellen zu den Stellwerken, ETCS-Nachbarzentralen und zum GSM-R." },
            { term: "Fahrdienstleiter", definition: "Fahrdienstleiter regeln die Durchführung der Zugfahrten. Fahrdienstleiter dürfen auch die Tätigkeiten von Weichenwärtern verrichten. Fahrdienstleiter und Weichenwärter sind in den Richtlinien 408.01-06 und 408.48 zusammenfassend in Kurzform auch als „Bediener“ angesprochen. Ein Bahnhof kann in mehrere Fahrdienstleiterbezirke aufgeteilt sein. Selbsttätige Blockstellen des automatischen Streckenblocks sind auf zweigleisigen Strecken dem Fahrdienstleiter der vorgelegenen Zugmeldestelle, auf eingleisigen Strecken einem festgelegten Fahrdienstleiter zugeteilt. Selbsttätige Blockstellen der übrigen Blockbauformen, Blockstellen für anzeigegeführte Züge oder örtlich nicht besetzte Bahnhöfe oder Abzweigstellen gelten als mit dem Fahrdienstleiter besetzt, der die Signalanlagen dieser Stellen bedient." },
            { term: "Fahrplanhalt", definition: "Es gibt folgende Fahrplanhalte: Regelhalt, Bedarfshalt, Betriebshalt und Halt zum Sichern eines Bahnübergangs." },
            { term: "Fahrtstellung eines Hauptsignals, Hauptsignal auf Fahrt stellen", definition: "Fahrtstellung eines Hauptsignals bzw. Formulierungen wie „ein Hauptsignal auf Fahrt stellen“ umfassen jede Signalstellung eines Hauptsignals, die es dem Triebfahrzeugführer eines Zuges erlaubt, an dem Signal vorbeizufahren, z. B. Signal Hp 2, Ks 1, HI 3a, Sv 4. An einer virtuellen Blockstelle entspricht der Fahrtstellung des Hauptsignals der entsprechende Fahrtmelder." },
            { term: "Fahrzeuge", definition: "Fahrzeuge werden unterschieden nach Regelfahrzeugen und Nebenfahrzeugen." },
            { term: "Fahrzeuge mit unzureichender Belegung von 42 Hz und 100 Hz-Gleisstromkreisen", definition: "Regelfahrzeuge oder schwere Nebenfahrzeuge, welche die Gleisfreimeldeanlagen der 42 Hz oder 100 Hz-Gleisstrom-Technik (Bauform WSSB) während der Fahrt nicht zuverlässig erkennen können, werden als \"Fahrzeuge mit unzureichender Belegung von 42 Hz und 100 Hz-Gleisstromkreisen\" bezeichnet." },
            { term: "Fehlleitung, fehlleiten", definition: "Ein Zug wird fehlgeleitet, wenn er in einen Fahrweg eingelassen wird, der nicht seinem Fahrplan oder seinem Auftrag entspricht." },
            { term: "Flankenschutzeinrichtungen", definition: "Flankenschutzeinrichtungen sind signaltechnische Einrichtungen, die Fahrten auf Fahrstraßen gegen Fahrzeugbewegungen schützen. Zu den Flankenschutzeinrichtungen gehören Weichen, Gleissperren, Sperrsignale, Hauptsignale ohne Signal Zs 103, Signale Ra 11 (DS 301) mit Lichtsignal Sh 1, sofern technisch ausgeschlossen ist, dass das Signal Sh 1 erteilt werden kann, solange das Wartezeichen als Flankenschutz für eine Zugfahrt dient, Signale Ra 11 a (DV 301) und alleinstehende Signale Ne 14." },
            { term: "Flankenschutzraum", definition: "Flankenschutzraum ist der Raum zwischen einer Flankenschutzeinrichtung oder einem Signal Ne 14 und dem Grenzzeichen einer Weiche oder Kreuzung im Fahrweg oder Durchrutschweg." },
            { term: "Führungsgrößen", definition: "Sollgeschwindigkeit, Zielgeschwindigkeit und Zielentfernung werden bei anzeigegeführten Zügen als Führungsgrößen bezeichnet und im Führerraum angezeigt." },
            { term: "FS (Full Supervision)", definition: "Betriebsart bei ETCS, bei der ein Zug in Vollüberwachung fährt, und zwar mit einer ETCS-Fahrterlaubnis, die ETCS dem Triebfahrzeugführer mit Führungsgrößen und einem Symbol in der Führerraumanzeige anzeigt." },
            { term: "Gegengleis", definition: "Das Gleis, das auf zweigleisiger, freier Strecke entgegen der gewöhnlichen Fahrtrichtung befahren wird, wird als Gegengleis bezeichnet." },
            { term: "Geschobene Züge", definition: "Geschobene Züge sind Züge, in denen kein arbeitendes Triebfahrzeug an der Spitze läuft oder von der Spitze aus gesteuert wird. Züge, die aus einem Nebenfahrzeug mit Kraftantrieb und einem vorangestellten Nebenfahrzeug ohne Kraftantrieb oder aus einem Triebfahrzeug und einem vorangestellten Schneeräumfahrzeug gebildet sind, sind keine geschobenen Züge, wenn die Fahrzeuge eine bauartkompatible Einheit bilden." },
            { term: "Gewöhnlicher Halteplatz", definition: "Der gewöhnliche Halteplatz ist die Stelle, an der ein Zug bei einem planmäßigen Halt dem Zweck des Haltes entsprechend halten muss. Im Einzelnen gilt Folgendes:\nDer gewöhnliche Halteplatz eines Reisezuges mit Betriebshalt oder eines Güterzuges ist möglichst nahe am Halt gebietenden Signal, vor dem LZB-Halt bzw. vor dem ETCS-Halt.\nDer gewöhnliche Halteplatz eines Reisezuges mit Regelhalt oder Bedarfshalt ist am Bahnsteig, hierbei müssen sich in der Regel alle für Reisende zum Ein- und Aussteigen vorgesehenen Türen am Bahnsteig befinden.\nDie Regeln zum gewöhnlichen Halteplatz gelten nicht für Halte zum Sichern eines Bahnüberganges." },
            { term: "Gleiswechselbetrieb", definition: "Gleiswechselbetrieb ist eingerichtet, wo das Gegengleis mit Hauptsignal und Signal Zs 6 befahren werden kann. Gleiswechselbetrieb kann ständig oder vorübergehend eingerichtet sein. Vorübergehend eingerichteter Gleiswechselbetrieb wird in einer Betra angeordnet." },
            { term: "Grenze zwischen Bahnhof und freier Strecke", definition: "Als Grenze zwischen den Bahnhöfen und der freien Strecke gelten im Allgemeinen die Einfahrsignale bzw. die sie ersetzenden Signale Ne 14 oder Trapeztafeln, sonst die Einfahrweichen. Bei besonderen örtlichen Verhältnissen kann die Grenze anderweitig festgelegt sein. Bahnhofsgleise und andere Anlagen neben den durchgehenden Hauptgleisen, die über die Grenze hinausreichen, gehören zu den Bahnhofsanlagen." },
            { term: "Grenzsignal", definition: "Ein Grenzsignal ist ein Hauptsignal, an dem eine Strecke mit ETCS beginnt oder endet." },
            { term: "Halt zum Sichern eines Bahnüberganges", definition: "Ein Halt zum Sichern eines Bahnüberganges ist ein Fahrplanhalt, bei dem ein Zug vor dem Bahnübergang anhalten muss, weil der Bahnübergang planmäßig durch Zugpersonal oder durch andere Mitarbeiter gesichert werden muss." },
            { term: "Haltepunkte", definition: "Haltepunkte sind Bahnanlagen ohne Weichen, wo Züge planmäßig halten, beginnen oder enden dürfen." },
            { term: "Haltestellen", definition: "Haltestellen sind Abzweigstellen, Überleitstellen oder Anschlussstellen, die mit einem Haltepunkt örtlich verbunden sind." },
            { term: "Hauptgleise", definition: "Hauptgleise sind die von Zügen planmäßig befahrenen Gleise." },
            { term: "IS (Isolation)", definition: "Betriebsart bei ETCS, wenn das ETCS-Fahrzeuggerät mit dem Störschalter ausgeschaltet ist. Es sind keine Eingaben und Anzeigen über die Fahrzeugeinrichtung möglich. Der Zug kann ohne ETCS-Fahrterlaubnis fahren." },
            { term: "Kleinwagen", definition: "Kleinwagen sind Nebenfahrzeuge, die Gleisschaltmittel oder Gleisfreimeldeanlagen nicht zuverlässig beeinflussen." },
            { term: "Kleinwagenfahrten", definition: "Kleinwagenfahrten sind Fahrten, die aus Kleinwagen gebildet sind oder in die Kleinwagen eingestellt sind. Sie dürfen nur als Sperrfahrt oder Rangierfahrt verkehren. Kleinwagenfahrten als Sperrfahrten sind nach den Regeln für Zugfahrten unter Beachtung der für Kleinwagenfahrten geltenden Besonderheiten durchzuführen. Kleinwagenfahrten als Rangierfahrten sind nach den Regeln für das Rangieren unter Beachtung der für Kleinwagen geltenden Besonderheiten durchzuführen." },
            { term: "Kontaktstelle", definition: "Kontaktstelle ist:\na) die Zugmeldestelle, die während der Arbeitsunterbrechung der überwachenden Zugmeldestelle bei der Notfallleitstelle für ein der überwachenden Zugmeldestelle zugeordnetes, gesperrtes Gleis Hilfe aufrufen muss,\nb) die Betriebsstelle, die die Meldungen zu Arbeitsende und Arbeitsbeginn bei unterbrochener Arbeitszeit entgegennimmt und der Besonderheiten während der unterbrochenen Arbeitszeit gemeldet werden." },
            { term: "Kreuzen", definition: "Beim Kreuzen wartet ein Zug auf einer Zugmeldestelle, weil der Zugfolgeabschnitt, in den er eingelassen werden soll, noch durch einen in der Gegenrichtung fahrenden Zug beansprucht wird." },
            { term: "Mitarbeiter", definition: "Mitarbeiter, im Sinne des bahnbetrieblichen Regelwerks, sind Personen, die Tätigkeiten im Bahnbetrieb selbstständig nur verrichten dürfen, wenn sie für diese Tätigkeiten geprüft und mit ihrer Ausführung beauftragt sind." },
            { term: "Nachgeschobene Züge", definition: "Nachgeschobene Züge sind Züge, in denen mindestens ein arbeitendes Triebfahrzeug an der Spitze läuft oder von der Spitze aus gesteuert wird und in denen bis zu zwei arbeitende Triebfahrzeuge laufen, die nicht von der Spitze aus gesteuert werden." },
            { term: "Nebenfahrzeuge", definition: "Nebenfahrzeuge werden unterschieden in Nebenfahrzeuge mit Kraftantrieb und in Nebenfahrzeuge ohne Kraftantrieb. Bestimmungen für Triebfahrzeuge gelten auch für Nebenfahrzeuge mit Kraftantrieb, sofern es nicht im Einzelfall anders bestimmt ist." },
            { term: "Nebengleise", definition: "Nebengleise sind Gleise, die planmäßig nicht von Zügen befahren werden." },
            { term: "NL (Non Leading)", definition: "Betriebsart bei ETCS, die der Triebfahrzeugführer der Zuglokomotive bei Vorspann bzw. eines mit dem Zug gekuppelten Schiebetriebfahrzeuges wählen muss." },
            { term: "Notbremsüberbrückungsabschnitt", definition: "Ein Notbremsüberbrückungsabschnitt ist ein durch NBÜ-Kennzeichen gekennzeichneter Abschnitt, in dem Züge bei einer Notbremsung nicht anhalten sollen." },
            { term: "NP (No Power)", definition: "Betriebsart bei ETCS, in die das ETCS-Fahrzeuggerät wechselt, wenn die Stromversorgung ausgeschaltet ist." },
            { term: "Ortsstellbereich", definition: "Ein Ortsstellbereich ist ein Bereich in Nebengleisen mit ortsgestellten Weichen und Gleissperren, in dem ausschließlich rangiert wird. Die Weichen und Gleissperren werden einzeln ggf. in Gruppen (elektrischer Antrieb) umgestellt. Die Bedienung erfolgt durch das Rangierpersonal. Zug- und Rangierstraßen sind nicht vorhanden. Ein für eine Rangierfahrt Halt gebietendes Signal begrenzt Ortsstellbereiche nach außen. Der Beginn eines Ortsstellbereiches kann durch ein Orientierungszeichen nach Richtlinie 301.9001 gekennzeichnet sein." },
            { term: "OS (On Sight)", definition: "Betriebsart bei ETCS, bei der ein Zug auf Sicht fahren muss, und zwar mit einer ETCS-Fahrterlaubnis, die dem Triebfahrzeugführer mit einem Symbol in der Führerraumanzeige angezeigt wird. ETCS überwacht die maximal zulässige Geschwindigkeit für Fahren auf Sicht und das Ende der ETCS-Fahrterlaubnis." },
            { term: "Override EOA", definition: "Funktion im ETCS-Fahrzeuggerät, die es dem Triebfahrzeugführer ermöglicht, aus den ETCS-Betriebsarten FS oder OS in die ETCS-Betriebsart SR zu wechseln sowie an einem ETCS-Halt vorbeizufahren." },
            { term: "Planmäßige Halte", definition: "Ein planmäßiger Halt kann:\n- als Fahrplanhalt im Fahrplan bzw. in einer Fahrplananordnung angeordnet sein oder\n- als zusätzlicher Halt angeordnet werden. Diese Anordnung darf das Eisenbahnverkehrsunternehmen erteilen." },
            { term: "PT (Post Trip)", definition: "Betriebsart bei ETCS, in die das ETCS-Fahrzeuggerät wechselt, nachdem der Triebfahrzeugführer im Stillstand die Betriebsart TR bestätigt hat." },
            { term: "Rangieren", definition: "Rangieren ist das Bewegen von Fahrzeugen im Bahnbetrieb, ausgenommen das Fahren der Züge. Das Bewegen von Fahrzeugen im Baugleis ist Rangieren. Beim Rangieren wird nachfolgenden Fahrzeugbewegungen unterschieden:\n- Rangierfahrt,\n- Abdrücken, Ablaufen,\n- Abstoßen,\n- Beidrücken,\n- Aufdrücken und\n- Verschieben." },
            { term: "Rangierfahrt", definition: "Eine Rangierfahrt ist eine Fahrzeugbewegung beim Rangieren, bei der\n- einzelne arbeitende Triebfahrzeuge oder\n- eine Gruppe gekuppelter Fahrzeuge, von denen mindestens ein Fahrzeug ein arbeitendes Triebfahrzeug ist,\nbewegt werden." },
            { term: "Regelfahrzeuge", definition: "Regelfahrzeuge werden unterschieden nach Triebfahrzeugen und Wagen." },
            { term: "Regelgleis", definition: "Das Gleis, das auf zweigleisiger, freier Strecke in der gewöhnlichen Fahrtrichtung befahren wird, wird als Regelgleis bezeichnet." },
            { term: "Regelhalt", definition: "Ein Regelhalt ist ein Fahrplanhalt, bei dem ein Zug auf der Betriebsstelle halten muss." },
            { term: "Regelzüge", definition: "Regelzüge sind Züge, die nach einem im Voraus festgelegten Fahrplan täglich oder an bestimmten Tagen verkehren." },
            { term: "Release Speed", definition: "Die Release Speed erlaubt in ETCS-Level 1 die Fahrt bis zu dem Signal mit der Balisengruppe, die der ETCS-Fahrzeugeinrichtung eine neue ETCS-Fahrterlaubnis übermittelt. In ETCS-Level 2 dient die Release Speed dem Ausgleich der Ungenauigkeiten der Wegmessung, indem sie es ermöglicht, bis zum zugehörigen Hauptsignal, Signal Ne 14, Blockkennzeichen oder Gleisabschluss vorzufahren." },
            { term: "SB (Stand By)", definition: "Betriebsart bei ETCS, bei der die ETCS-Fahrzeugeinrichtung in Bereitschaft ist und die dem Triebfahrzeugführer durch ein Symbol in der Führerraumanzeige angezeigt wird. In der Betriebsart SB ist der Zug noch ohne ETCS-Fahrterlaubnis." },
            { term: "SF (System Failure)", definition: "Betriebsart bei ETCS, in die die ETCS-Fahrzeugeinrichtung bei sicherheitsrelevanten Fehlern wechselt. Gleichzeitig leitet die ETCS-Fahrzeugeinrichtung eine Zwangsbremsung ein." },
            { term: "Schneeräumfahrten", definition: "Schneeräumfahrten sind Fahrten mit arbeitenden Schneeräumern - außer Fahrten mit Schneepflügen, die mit dem Triebfahrzeug fest verbunden sind." },
            { term: "Selbsttätige Blockstellen", definition: "Selbsttätige Blockstellen sind Blockstellen der freien Strecke, wo selbsttätiger Streckenblock eingerichtet ist, ausgenommen Abzweigstellen oder Überleitstellen." },
            { term: "Selbststellbetrieb, Zuglenkung", definition: "Bei Selbststellbetrieb oder bei Zuglenkung mit Lenkplan werden Zugstraßen selbsttätig eingestellt." },
            { term: "SH (Shunting)", definition: "Betriebsart bei ETCS, bei der ein Zug oder eine Rangierfahrt ohne ETCS-Fahrterlaubnis fahren kann und die ETCS dem Triebfahrzeugführer durch ein Symbol in der Führerraumanzeige anzeigt; die Fahrterlaubnis erhält der Triebfahrzeugführer durch einen Befehl bzw. beim Rangieren durch Zustimmung des Weichenwärters." },
            { term: "Signalgeführt", definition: "Züge sind signalgeführt, wenn sie nicht anzeigegeführt sind." },
            { term: "Sollgeschwindigkeit", definition: "Die Sollgeschwindigkeit ist die als V-soll angezeigte Geschwindigkeit für einen anzeigegeführten Zug, mit der ein Zug fahren kann, ohne dass LZB oder ETCS eine Warnung ausgibt oder eine Bremsung einleitet." },
            { term: "Sperrfahrten", definition: "Sperrfahrten sind Züge oder Kleinwagenfahrten, die in ein Gleis der freien Strecke eingelassen werden, das gesperrt ist." },
            { term: "SR (Staff Responsible)", definition: "Betriebsart bei ETCS, bei der ETCS die zulässige Geschwindigkeit für SR und das Ende der Fahrterlaubnis durch Balisen mit der Information „Halt für Züge in der ETCS-Betriebsart SR“ am Signal Ne 14 überwacht. ETCS zeigt dem Triebfahrzeugführer die Betriebsart SR durch ein Symbol in der Führerraumanzeige an. Die Fahrterlaubnis erhält der Triebfahrzeugführer durch einen Befehl, bei ETCS-Level 1 auch durch ein Signal oder bei ETCS-Level 2 auch durch eine Textmeldung." },
            { term: "Strecken mit Stichstreckenblock", definition: "Strecken mit Stichstreckenblock sind eingleisige Stichstrecken, die mit Streckenblock ausgerüstet sind und nur aus einem Zugfolgeabschnitt bestehen. Dabei befinden sich alle Bedieneinrichtungen des Stichstreckenblocks auf der angrenzenden Zugmeldestelle." },
            { term: "TR (Trip)", definition: "Betriebsart bei ETCS, in die das ETCS-Fahrzeuggerät nach Überfahren eines ETCS-Haltes oder in bestimmten Störsituationen wechselt." },
            { term: "Triebfahrzeuge", definition: "Triebfahrzeuge sind Lokomotiven, Triebwagen, Triebköpfe und Triebzüge sowie Kleinlokomotiven." },
            { term: "Überholen", definition: "Beim Überholen fährt ein Zug an einem anderen Zug derselben Fahrtrichtung vorbei." },
            { term: "Überleitstellen", definition: "Überleitstellen sind Blockstellen der freien Strecke, wo Züge auf ein anderes Gleis derselben Strecke übergehen können." },
            { term: "Ungesteuerte Fahrzeuge", definition: "Ungesteuerte Fahrzeuge sind Fahrzeuge, die beim Rangieren durch Schwerkraft, durch Abstoßen oder durch losgelassene, rollende Fahrzeuge bewegt werden. Ungesteuerte Fahrzeuge sind auch Fahrzeuge, die im Fahrbetrieb ohne führenden Triebfahrzeugführer in Bewegung gesetzt werden." },
            { term: "Verschieben", definition: "Verschieben ist das Bewegen von Fahrzeugen, die nicht von einem arbeitenden Triebfahrzeug aus gesteuert werden, wobei die Rangierer vom Fahrzeug abspringen oder aufspringen können." },
            { term: "Virtuelle Blockstelle", definition: "Eine virtuelle Blockstelle ist eine Stelle der freien Strecke, die eine Blockstrecke für anzeigegeführte Züge begrenzt." },
            { term: "Vorspann", definition: "Ein Vorspann ist ein Zug, der aus zwei oder mehr Triebfahrzeugen an der Spitze gebildet wird, die nicht gesteuert werden. Dabei ist nur das erste Triebfahrzeug führend." },
            { term: "Wagen", definition: "Wagen sind Fahrzeuge ohne eigenen Antrieb." },
            { term: "Weichenwärter", definition: "Weichenwärter stellen die Weichen und Gleissperren für die Zugfahrten, ausgenommen bei selbsttätigem Streckenblock oder Zuglenkung." },
            { term: "Zug", definition: "Ein Zug ist eine auf der freien Strecke oder im Bahnhof, abweichend vom Regelfall, auf den durchgehenden Hauptgleisen, bewegte Einheit, die aus einem oder mehreren Triebfahrzeugen mit oder ohne Wagen oder aus einem Nebenfahrzeug mit Kraftantrieb besteht. Das Bewegen der Einheit ist eine Zugfahrt, auch wenn ein Nebenfahrzeug mit Kraftantrieb als Sperrfahrt verkehrt." },
            { term: "Zugbildungsbahnhof", definition: "Ein Zugbildungsbahnhof ist ein Bahnhof, in dem Züge gebildet werden." },
            { term: "Zugfahrt", definition: "Eine Zugfahrt ist die Fahrt eines Zuges. Zugfahrten werden unterschieden nach planmäßigen und zusätzlichen Zugfahrten." },
            { term: "Zugfolgeabschnitte", definition: "Zugfolgeabschnitte sind Gleisabschnitte der freien Strecke, in die jeweils nur ein Zug eingelassen werden darf. Zugfolgeabschnitte können durch Blockstellen, Abzweigstellen oder Überleitstellen begrenzt sein. Es gibt Zugfolgeabschnitte für signalgeführte und anzeigegeführte Züge." },
            { term: "Zuglaufmeldung", definition: "Zuglaufmeldungen sind Informationen über den Lauf der Züge, insbesondere:\n- Zugnummer,\n- Abfahrtszeit,\n- Ankunftszeit,\n- voraussichtliche Ankunftszeit,\n- Verspätung,\n- Zeit der Abfahrt bzw. Ankunft und\n- Grund der Verspätung." },
            { term: "Zugschluss", definition: "Der Zugschluss ist das letzte Fahrzeug des Zuges." },
            { term: "Zugverzeichnis", definition: "Ein Zugverzeichnis ist ein Verzeichnis der Züge, in dem die Zugnummer, der Zugname, die Zugart, die Zuglänge, die Last, die Bremsart und der Bremszug angegeben sind." },
            { term: "Zugnummer", definition: "Die Zugnummer ist die Nummer, die einen Zug eindeutig identifiziert. Die Zugnummer wird in der Regel durch das Eisenbahnverkehrsunternehmen vergeben." },
            { term: "Zugmeldestellen", definition: "Zugmeldestellen sind Betriebsstellen, die der Zugfolge auf der freien Strecke dienen. Bahnhöfe, Abzweigstellen, Überleitstellen und Haltestellen sind stets Zugmeldestellen. Auf Strecken mit Stichstreckenblock kann eine Blockstelle auch als Zugmeldestelle gelten." },
            { term: "Zugpersonal", definition: "Zugpersonal sind die Mitarbeiter, die auf einem Triebfahrzeug oder in einem Zug an der Durchführung von Zugfahrten beteiligt sind." }
        ];
        
        let learningProgress = {};
        
        const totalTermsCount = definitions.length;
        let selectedTerms = [];
        let currentSessionTerms = [];
        let score = 0;
        let currentIndex = 0;
        let currentMode = 'learn';
        let feedbackQueue = [];
        let folders = {};

        const loader = document.getElementById('loader');
        const mainView = document.getElementById('main-view');
        const settingsView = document.getElementById('settings-view');
        const settingsContent = document.getElementById('settings-content');
        const startBtn = document.getElementById('start-btn');
        const noSelectionWarning = document.getElementById('no-selection-warning');
        const progressDashboard = document.getElementById('progress-dashboard');
        const searchInput = document.getElementById('search-input');
        const termSelectionDiv = document.getElementById('term-selection');
        const selectionCountSpan = document.getElementById('selection-count');
        const searchResultsCountSpan = document.getElementById('search-results-count');
        const selectAllBtn = document.getElementById('select-all');
        const deselectAllBtn = document.getElementById('deselect-all');
        const selectVisibleBtn = document.getElementById('select-visible');
        const clearSearchBtn = document.getElementById('clear-search');
        
        // Ordner-Elemente
        const newFolderInput = document.getElementById('new-folder-input');
        const addFolderBtn = document.getElementById('add-folder-btn');
        const folderListDiv = document.getElementById('folder-list');
        const folderSelectionCount = document.getElementById('folder-selection-count');

        // Initialisierung
        document.addEventListener('DOMContentLoaded', () => {
            loadProgress();
            loadFolders();
            renderTermSelection();
            renderFolderList();
            updateDashboard();
            hideLoader();
        });

        function hideLoader() {
            loader.classList.add('hidden');
        }

        // --- Ordner-Funktionen ---
        function loadFolders() {
            const savedFolders = localStorage.getItem('termFolders');
            if (savedFolders) {
                folders = JSON.parse(savedFolders);
            } else {
                folders = {
                    "Alle Begriffe": definitions.map(d => d.term)
                };
                saveFolders();
            }
        }

        function saveFolders() {
            localStorage.setItem('termFolders', JSON.stringify(folders));
            renderFolderList();
            renderTermSelection();
        }

        function renderFolderList() {
            folderListDiv.innerHTML = '';
            const allTerms = definitions.map(d => d.term);
            
            // Fügen Sie den "Alle Begriffe" Ordner hinzu
            const allFolderItem = document.createElement('div');
            allFolderItem.className = 'folder-item bg-gray-200 font-semibold';
            allFolderItem.innerHTML = `
                <span>Alle Begriffe (${allTerms.length})</span>
            `;
            folderListDiv.appendChild(allFolderItem);
            
            // Fügen Sie die benutzerdefinierten Ordner hinzu
            for (const folderName in folders) {
                if (folderName === "Alle Begriffe") continue;
                const termsInFolderCount = folders[folderName].length;
                const folderItem = document.createElement('div');
                folderItem.className = 'folder-item';
                folderItem.innerHTML = `
                    <span>${folderName} (${termsInFolderCount})</span>
                    <div>
                        <button class="edit-folder-btn text-blue-500 hover:text-blue-700 font-bold py-1 px-2 rounded">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                            </svg>
                        </button>
                        <button class="delete-folder-btn text-red-500 hover:text-red-700 font-bold py-1 px-2 rounded">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                `;
                folderItem.dataset.folderName = folderName;
                folderListDiv.appendChild(folderItem);
            }
            updateFolderSelectionCount();
        }

        function updateFolderSelectionCount() {
            const selectedFolders = Object.values(folders).flat();
            const uniqueTerms = new Set(selectedFolders);
            folderSelectionCount.textContent = `${uniqueTerms.size} Begriffe in Ordnern`;
        }
        
        addFolderBtn.addEventListener('click', () => {
            const folderName = newFolderInput.value.trim();
            if (folderName && !folders[folderName]) {
                folders[folderName] = [];
                saveFolders();
                newFolderInput.value = '';
            }
        });

        folderListDiv.addEventListener('click', (e) => {
            const target = e.target.closest('.folder-item button');
            if (!target) return;

            const folderItem = target.closest('.folder-item');
            const folderName = folderItem.dataset.folderName;

            if (target.classList.contains('delete-folder-btn')) {
                if (confirm(`Sind Sie sicher, dass Sie den Ordner "${folderName}" löschen möchten? Die Begriffe bleiben erhalten.`)) {
                    delete folders[folderName];
                    saveFolders();
                }
            } else if (target.classList.contains('edit-folder-btn')) {
                const newName = prompt(`Neuer Name für den Ordner "${folderName}":`, folderName);
                if (newName && newName.trim() !== folderName && !folders[newName]) {
                    folders[newName] = folders[folderName];
                    delete folders[folderName];
                    saveFolders();
                }
            }
        });

        // --- Ende Ordner-Funktionen ---

        // --- Begriffe zuordnen Funktionen ---
        function getFolderForTerm(term) {
            for (const folderName in folders) {
                if (folders[folderName].includes(term)) {
                    return folderName;
                }
            }
            return null;
        }

        function addTermToFolder(folderName, term) {
            if (!folders[folderName]) return;
            if (!folders[folderName].includes(term)) {
                folders[folderName].push(term);
                saveFolders();
            }
        }

        function removeTermFromFolder(folderName, term) {
            if (!folders[folderName]) return;
            const index = folders[folderName].indexOf(term);
            if (index > -1) {
                folders[folderName].splice(index, 1);
                saveFolders();
            }
        }

        // --- Ende Begriffe zuordnen Funktionen ---

        // --- Bestehende Funktionen angepasst ---
        function renderTermSelection() {
            const searchTerm = searchInput.value.toLowerCase();
            const filteredTerms = definitions.filter(d =>
                d.term.toLowerCase().includes(searchTerm) || d.definition.toLowerCase().includes(searchTerm)
            );

            termSelectionDiv.innerHTML = '';
            
            if (searchTerm.length > 0) {
                searchResultsCountSpan.textContent = `${filteredTerms.length} Ergebnisse gefunden`;
                searchResultsCountSpan.classList.remove('hidden');
                selectVisibleBtn.classList.remove('hidden');
                clearSearchBtn.classList.remove('hidden');
            } else {
                searchResultsCountSpan.classList.add('hidden');
                selectVisibleBtn.classList.add('hidden');
                clearSearchBtn.classList.add('hidden');
            }

            if (filteredTerms.length === 0 && searchTerm.length > 0) {
                termSelectionDiv.innerHTML = `<p class="text-center text-gray-500 p-4">Keine Begriffe gefunden.</p>`;
                return;
            }

            filteredTerms.forEach(def => {
                const isSelected = selectedTerms.includes(def.term);
                const folderName = getFolderForTerm(def.term);
                const item = document.createElement('div');
                item.className = `term-selection-item p-3 rounded-lg cursor-pointer transition flex justify-between items-center ${isSelected ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 hover:bg-gray-200'}`;
                item.dataset.term = def.term;
                
                let html = `
                    <span>${def.term}</span>
                    <div class="flex items-center space-x-2">
                        <select class="folder-select p-1 border rounded text-gray-700">
                            <option value="">Kein Ordner</option>
                            ${Object.keys(folders).filter(name => name !== "Alle Begriffe").map(name => 
                                `<option value="${name}" ${folderName === name ? 'selected' : ''}>${name}</option>`
                            ).join('')}
                        </select>
                        <input type="checkbox" class="term-checkbox h-5 w-5 accent-[--eb-teal]" ${isSelected ? 'checked' : ''}>
                    </div>
                `;
                item.innerHTML = html;
                termSelectionDiv.appendChild(item);
            });
            updateSelectionCount();

            // Event-Listener für Checkboxen und Dropdowns
            termSelectionDiv.querySelectorAll('.term-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const term = e.target.closest('.term-selection-item').dataset.term;
                    toggleTermSelection(term, e.target.checked);
                });
            });

            termSelectionDiv.querySelectorAll('.folder-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const term = e.target.closest('.term-selection-item').dataset.term;
                    const newFolder = e.target.value;
                    const oldFolder = getFolderForTerm(term);

                    if (oldFolder) {
                        removeTermFromFolder(oldFolder, term);
                    }
                    if (newFolder) {
                        addTermToFolder(newFolder, term);
                    }
                    updateFolderSelectionCount();
                });
            });
        }

        function toggleTermSelection(term, isSelected) {
            if (isSelected) {
                if (!selectedTerms.includes(term)) {
                    selectedTerms.push(term);
                }
            } else {
                selectedTerms = selectedTerms.filter(t => t !== term);
            }
            updateSelectionCount();
        }

        function updateSelectionCount() {
            selectionCountSpan.textContent = `${selectedTerms.length} Begriffe ausgewählt`;
        }

        searchInput.addEventListener('input', renderTermSelection);

        selectAllBtn.addEventListener('click', () => {
            const allTerms = definitions.map(d => d.term);
            selectedTerms = [...new Set([...selectedTerms, ...allTerms])];
            renderTermSelection();
        });

        deselectAllBtn.addEventListener('click', () => {
            selectedTerms = [];
            renderTermSelection();
        });

        selectVisibleBtn.addEventListener('click', () => {
            const searchTerm = searchInput.value.toLowerCase();
            const visibleTerms = definitions.filter(d =>
                d.term.toLowerCase().includes(searchTerm) || d.definition.toLowerCase().includes(searchTerm)
            ).map(d => d.term);
            selectedTerms = [...new Set([...selectedTerms, ...visibleTerms])];
            renderTermSelection();
        });

        clearSearchBtn.addEventListener('click', () => {
            searchInput.value = '';
            renderTermSelection();
        });

        startBtn.addEventListener('click', () => {
            if (selectedTerms.length === 0) {
                noSelectionWarning.classList.remove('hidden');
                return;
            }
            noSelectionWarning.classList.add('hidden');
            currentSessionTerms = selectedTerms.map(term => definitions.find(d => d.term === term));
            
            // Mischen Sie die ausgewählten Begriffe für eine neue Sitzung
            currentSessionTerms = shuffleArray(currentSessionTerms);
            
            startSession();
        });

        // --- Ende bestehende Funktionen angepasst ---
        
        // Unveränderter Code, nur der Übersicht halber
        function loadProgress() {
            const progress = localStorage.getItem('learningProgress');
            if (progress) {
                Object.assign(learningProgress, JSON.parse(progress));
            }
        }
        
        function saveProgress() {
            localStorage.setItem('learningProgress', JSON.stringify(learningProgress));
            updateDashboard();
        }
        
        function updateDashboard() {
            const totalCount = definitions.length;
            const knownCount = Object.keys(learningProgress).filter(term => learningProgress[term] === 'known').length;
            const unknownCount = Object.keys(learningProgress).filter(term => learningProgress[term] === 'unknown').length;
            const neutralCount = totalCount - knownCount - unknownCount;
            const evaluatedCount = knownCount + unknownCount;
            const progressPercentage = totalCount > 0 ? Math.round((evaluatedCount / totalCount) * 100) : 0;
            
            document.getElementById('total-terms').textContent = totalCount;
            document.getElementById('known-count').textContent = knownCount;
            document.getElementById('unknown-count').textContent = unknownCount;
            document.getElementById('neutral-count').textContent = neutralCount;
            document.getElementById('progress-bar').style.width = `${progressPercentage}%`;
            document.getElementById('progress-text').textContent = `${progressPercentage}% bewertet`;
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startSession() {
            currentMode = document.querySelector('input[name="mode"]:checked').value;
            currentIndex = 0;
            score = 0;
            feedbackQueue = [];
            settingsView.classList.add('hidden');
            mainView.classList.remove('hidden');
            showNextCard();
        }

        function showNextCard() {
            if (currentIndex >= currentSessionTerms.length) {
                showEndScreen();
                return;
            }
            
            const currentTerm = currentSessionTerms[currentIndex];
            mainView.innerHTML = '';
            
            if (currentMode === 'learn') {
                renderFlashcard(currentTerm);
            } else if (currentMode === 'test-term') {
                renderTestQuiz(currentTerm, 'term');
            } else if (currentMode === 'test-def') {
                renderTestQuiz(currentTerm, 'def');
            }
        }

        function renderFlashcard(termData) {
            const cardHtml = `
                <div class="card-container w-full max-w-2xl h-80">
                    <div id="flashcard" class="card w-full h-full relative">
                        <div class="card-face card-face-front">
                            <h2 class="text-xl md:text-2xl font-bold text-[--eb-dark-blue] text-center p-4">
                                ${termData.term}
                            </h2>
                        </div>
                        <div class="card-face card-face-back p-4">
                            <div class="card-header bg-[--eb-teal]">
                                <h2 class="text-lg md:text-xl font-bold p-1">Definition</h2>
                            </div>
                            <div class="card-content">
                                <p class="text-base md:text-lg">${termData.definition.replace(/\n/g, '<br>')}</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="mt-8 text-center">
                    <button id="flip-btn" class="bg-[--eb-medium-blue] hover:bg-[--eb-dark-blue] text-white font-bold py-2 px-6 rounded-lg transition">Umblättern</button>
                    <div id="rating-buttons" class="hidden mt-4 space-x-4">
                        <button class="rate-btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition" data-rating="known">Gewusst</button>
                        <button class="rate-btn bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg transition" data-rating="unknown">Nicht gewusst</button>
                    </div>
                </div>
            `;
            mainView.innerHTML = cardHtml;
            const card = document.getElementById('flashcard');
            const flipBtn = document.getElementById('flip-btn');
            const ratingButtons = document.getElementById('rating-buttons');

            flipBtn.addEventListener('click', () => {
                card.classList.add('is-flipped');
                flipBtn.classList.add('hidden');
                ratingButtons.classList.remove('hidden');
            });
            
            document.querySelectorAll('.rate-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const rating = btn.dataset.rating;
                    learningProgress[termData.term] = rating;
                    saveProgress();
                    currentIndex++;
                    showNextCard();
                });
            });
        }
        
        function renderTestQuiz(termData, type) {
            let questionHtml = '';
            let correctAnswer;
            let feedbackText = '';
            let quizType = '';

            if (type === 'term') {
                quizType = 'test-term';
                questionHtml = `<h2 class="text-xl md:text-2xl font-bold mb-4 text-[--eb-dark-blue]">Welchem Begriff entspricht diese Definition?</h2><div class="bg-gray-100 p-4 rounded-lg"><p class="text-base md:text-lg">${termData.definition.replace(/\n/g, '<br>')}</p></div>`;
                correctAnswer = termData.term;
            } else if (type === 'def') {
                quizType = 'test-def';
                questionHtml = `<h2 class="text-xl md:text-2xl font-bold mb-4 text-[--eb-dark-blue]">Wie lautet die Definition für: <span class="text-[--eb-teal]">${termData.term}</span>?</h2>`;
                correctAnswer = termData.definition;
            }

            const quizHtml = `
                <div class="definition-quiz w-full max-w-3xl bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                    ${questionHtml}
                    ${type === 'def' ? `<textarea id="answer-input" rows="6" class="w-full p-3 border rounded-lg resize-y"></textarea>` :
                    `<div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>`}
                    <div id="feedback" class="mt-4 p-4 rounded-lg hidden"></div>
                    <div class="mt-6 flex flex-wrap gap-4">
                        <button id="check-btn" class="bg-[--eb-teal] hover:bg-[#358f8f] text-white font-bold py-2 px-6 rounded-lg transition">Prüfen</button>
                        <button id="show-answer-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-6 rounded-lg transition">Antwort anzeigen</button>
                        <div id="nav-buttons" class="hidden ml-auto flex flex-wrap gap-4">
                            <button id="next-btn" class="bg-[--eb-medium-blue] hover:bg-[--eb-dark-blue] text-white font-bold py-2 px-6 rounded-lg transition">Weiter</button>
                            <button id="mark-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition">Bewerten</button>
                        </div>
                    </div>
                </div>
            `;
            mainView.innerHTML = quizHtml;

            const checkBtn = document.getElementById('check-btn');
            const showAnswerBtn = document.getElementById('show-answer-btn');
            const feedbackDiv = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const markBtn = document.getElementById('mark-btn');
            
            if (type === 'def') {
                const answerInput = document.getElementById('answer-input');
                checkBtn.addEventListener('click', () => checkDefinitionAnswer(answerInput.value, correctAnswer));
                showAnswerBtn.addEventListener('click', () => showDefinitionAnswer(correctAnswer));
            } else {
                const optionsContainer = document.getElementById('options-container');
                const options = generateOptions(termData);
                options.forEach(option => {
                    const optionBtn = document.createElement('button');
                    optionBtn.className = 'answer-option bg-gray-100 hover:bg-gray-200 text-gray-800 font-medium p-4 rounded-lg text-left transition duration-200 border-2 border-transparent';
                    optionBtn.textContent = option;
                    optionBtn.dataset.answer = option;
                    optionsContainer.appendChild(optionBtn);

                    optionBtn.addEventListener('click', () => checkTermAnswer(optionBtn, correctAnswer));
                });
                showAnswerBtn.addEventListener('click', () => showTermAnswer(correctAnswer));
            }

            nextBtn.addEventListener('click', () => {
                currentIndex++;
                showNextCard();
            });

            markBtn.addEventListener('click', () => {
                // Diese Funktion wird in der nächsten Antwort hinzugefügt
                alert('Diese Funktion ist noch nicht implementiert.');
            });
        }
        
        function generateOptions(termData) {
            const allTerms = definitions.map(d => d.term);
            const correctTerm = termData.term;
            
            let options = [correctTerm];
            while (options.length < 4) {
                const randomTerm = allTerms[Math.floor(Math.random() * allTerms.length)];
                if (!options.includes(randomTerm)) {
                    options.push(randomTerm);
                }
            }
            return shuffleArray(options);
        }

        function checkTermAnswer(selectedBtn, correctAnswer) {
            const isCorrect = selectedBtn.dataset.answer === correctAnswer;
            const options = document.querySelectorAll('.answer-option');
            
            options.forEach(btn => {
                if (btn.dataset.answer === correctAnswer) {
                    btn.classList.add('correct-answer');
                }
                btn.disabled = true;
            });
            
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.classList.remove('hidden');

            if (isCorrect) {
                feedbackDiv.textContent = 'Richtig!';
                feedbackDiv.classList.add('correct-answer');
                feedbackDiv.classList.remove('wrong-answer');
                score++;
                learningProgress[selectedBtn.closest('.definition-quiz').querySelector('h2').textContent.split(': ')[1].replace('?', '').trim()] = 'known';
            } else {
                selectedBtn.classList.add('wrong-answer');
                feedbackDiv.textContent = 'Leider falsch.';
                feedbackDiv.classList.add('wrong-answer');
                feedbackDiv.classList.remove('correct-answer');
                learningProgress[selectedBtn.closest('.definition-quiz').querySelector('h2').textContent.split(': ')[1].replace('?', '').trim()] = 'unknown';
            }
            
            saveProgress();
            
            document.getElementById('check-btn').classList.add('hidden');
            document.getElementById('show-answer-btn').classList.add('hidden');
            document.getElementById('nav-buttons').classList.remove('hidden');
        }
        
        function showTermAnswer(correctAnswer) {
            const options = document.querySelectorAll('.answer-option');
            options.forEach(btn => {
                if (btn.dataset.answer === correctAnswer) {
                    btn.classList.add('correct-answer');
                }
                btn.disabled = true;
            });

            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.classList.remove('hidden');
            feedbackDiv.textContent = `Die richtige Antwort ist: ${correctAnswer}`;
            feedbackDiv.classList.add('bg-gray-200');
            
            document.getElementById('check-btn').classList.add('hidden');
            document.getElementById('show-answer-btn').classList.add('hidden');
            document.getElementById('nav-buttons').classList.remove('hidden');
            learningProgress[document.getElementById('main-view').querySelector('h2').textContent.split(': ')[1].replace('?', '').trim()] = 'unknown';
            saveProgress();
        }

        function checkDefinitionAnswer(userAnswer, correctAnswer) {
            const diff = JsDiff.diffChars(correctAnswer, userAnswer);
            let feedbackHtml = '';
            let isCorrect = true;

            diff.forEach((part) => {
                if (part.added) {
                    feedbackHtml += `<del class="text-red-700">${part.value}</del>`;
                    isCorrect = false;
                } else if (part.removed) {
                    feedbackHtml += `<ins class="text-green-700">${part.value}</ins>`;
                    isCorrect = false;
                } else {
                    feedbackHtml += part.value;
                }
            });

            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.innerHTML = feedbackHtml;
            feedbackDiv.classList.remove('hidden');

            const resultText = document.createElement('p');
            resultText.className = 'text-lg font-semibold mt-2';
            if (isCorrect) {
                resultText.textContent = 'Richtig! Perfekt.';
                score++;
                learningProgress[document.getElementById('main-view').querySelector('h2').textContent.split(': ')[1].replace('?', '').trim()] = 'known';
            } else {
                resultText.textContent = 'Leider falsch. Die richtigen Antworten sind rot und die falschen grün markiert.';
                learningProgress[document.getElementById('main-view').querySelector('h2').textContent.split(': ')[1].replace('?', '').trim()] = 'unknown';
            }
            feedbackDiv.prepend(resultText);
            
            saveProgress();
            
            document.getElementById('check-btn').classList.add('hidden');
            document.getElementById('show-answer-btn').classList.add('hidden');
            document.getElementById('nav-buttons').classList.remove('hidden');
        }

        function showDefinitionAnswer(correctAnswer) {
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.textContent = `Die richtige Antwort lautet: ${correctAnswer}`;
            feedbackDiv.classList.remove('hidden');
            feedbackDiv.classList.add('bg-gray-200');
            
            document.getElementById('check-btn').classList.add('hidden');
            document.getElementById('show-answer-btn').classList.add('hidden');
            document.getElementById('nav-buttons').classList.remove('hidden');
            learningProgress[document.getElementById('main-view').querySelector('h2').textContent.split(': ')[1].replace('?', '').trim()] = 'unknown';
            saveProgress();
        }

        function showEndScreen() {
            let message = '';
            if (currentMode.startsWith('test')) {
                const percentage = currentSessionTerms.length > 0 ? Math.round((score / currentSessionTerms.length) * 100) : 0;
                message = `
                    <h2 class="text-3xl font-bold mb-4">Test beendet!</h2>
                    <p class="text-xl">Du hast ${score} von ${currentSessionTerms.length} Begriffen richtig beantwortet.</p>
                    <p class="text-5xl font-bold mt-4 text-[--eb-teal]">${percentage}%</p>
                `;
            } else {
                message = `<h2 class="text-3xl font-bold mb-4">Lernsitzung beendet!</h2><p class="text-xl">Du hast alle ausgewählten Karteikarten durchgesehen.</p>`;
            }

            mainView.innerHTML = `
                <div class="text-center bg-white p-10 rounded-xl shadow-lg border border-gray-200">
                    ${message}
                    <div class="mt-8">
                        <button id="restart-btn" class="bg-[--eb-teal] hover:bg-[#358f8f] text-white font-bold py-3 px-6 rounded-lg transition">Neue Sitzung starten</button>
                    </div>
                </div>
            `;
            document.getElementById('restart-btn').addEventListener('click', () => {
                mainView.classList.add('hidden');
                settingsView.classList.remove('hidden');
                selectedTerms = []; // Alle Auswahlen zurücksetzen
                renderTermSelection();
            });
        }

        document.getElementById('reset-progress').addEventListener('click', () => {
            if (confirm('Möchten Sie Ihren gesamten Lernfortschritt wirklich zurücksetzen?')) {
                localStorage.removeItem('learningProgress');
                learningProgress = {};
                updateDashboard();
            }
        });

        document.getElementById('filter-all').addEventListener('click', () => {
            selectedTerms = definitions.map(d => d.term);
            renderTermSelection();
        });

        document.getElementById('filter-unknown').addEventListener('click', () => {
            selectedTerms = Object.keys(learningProgress).filter(term => learningProgress[term] === 'unknown');
            renderTermSelection();
        });
        
        document.getElementById('filter-known').addEventListener('click', () => {
            selectedTerms = Object.keys(learningProgress).filter(term => learningProgress[term] === 'known');
            renderTermSelection();
        });
        
        document.getElementById('filter-neutral').addEventListener('click', () => {
            const evaluatedTerms = Object.keys(learningProgress);
            selectedTerms = definitions.filter(d => !evaluatedTerms.includes(d.term)).map(d => d.term);
            renderTermSelection();
        });
        
    </script>
</body>
</html>
